代码随想录算法训练营第44天



今日内容： 

​                ● 完全背包

​                ● 518. 零钱兑换 II 

​                ● 377. 组合总和 Ⅳ 







[完全背包](https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html)

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。

**完全背包和01背包问题唯一不同的地方就是，每种物品有无限件**。

同样leetcode上没有纯完全背包问题，都是需要完全背包的各种应用，需要转化成完全背包问题，所以我这里还是以纯完全背包问题进行讲解理论和原理。在下面依然举这个例子：

背包最大重量为4。物品为：

|       | 重量 | 价值 |
| ----- | ---- | ---- |
| 物品0 | 1    | 15   |
| 物品1 | 3    | 20   |
| 物品2 | 4    | 30   |

**每件商品都有无限个！**



再回顾一下01背包的核心代码

```cpp
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

我们知道01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。

而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：

```cpp
// 先遍历物品，再遍历背包
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j <= bagWeight ; j++) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```







[494.目标和](https://leetcode.cn/problems/target-sum/)

给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的<u>方法数</u>。





## 回溯算法

在回溯算法系列中，学过这道题目[回溯算法：39. 组合总和 ](https://programmercarl.com/0039.组合总和.html)应该感觉很熟悉，这不就是组合总和问题么？

此时可以套组合总和的回溯法代码，几乎不用改动。当然，也可以转变成序列区间选+ 或者 -，使用回溯法，那就是另一个解法。

但是肯定超时

```cpp
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {
        if (sum == target) {
            result.push_back(path);
        }
        // 如果 sum + candidates[i] > target 就终止遍历
        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {
            sum += candidates[i];
            path.push_back(candidates[i]);
            backtracking(candidates, target, sum, i + 1);
            sum -= candidates[i];
            path.pop_back();

        }
    }
public:
    int findTargetSumWays(vector<int>& nums, int S) {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) sum += nums[i];
        if (S > sum) return 0; // 此时没有方案
        if ((S + sum) % 2) return 0; // 此时没有方案，两个int相加的时候要各位小心数值溢出的问题
        int bagSize = (S + sum) / 2; // 转变为组合总和问题，bagsize就是要求的和

        // 以下为回溯法代码
        result.clear();
        path.clear();
        sort(nums.begin(), nums.end()); // 需要排序
        backtracking(nums, bagSize, 0, 0);
        return result.size();
    }
};
```



## 动态规划

假设加法的总和为x，那么减法对应的总和就是sum - x。

所以我们要求的是 x - (sum - x) = target                          x = (target + sum) / 2

**此时问题就转化为，装满容量为x的背包，有几种方法**。

这里的x，就是bagSize，也就是我们后面要求的背包容量。

大家看到(target + sum) / 2 应该担心计算的过程中向下取整有没有影响。

担心就对了，例如sum 是5，target （即S）是2的话其实就是无解的，所以：

```cpp
if ((target + sum) % 2 == 1) return 0; // 此时没有方案
```

同时如果 target的绝对值已经大于sum，那么也是没有方案的。

```cpp
if (abs(target) > sum) return 0; // 此时没有方案
```

为什么是01背包呢？因为**每个物品（题目中的1）只用一次！**

这次和之前遇到的背包问题不一样了，**之前都是求容量为j的背包，最多能装多少。** **本题则是装满<u>有几种方法</u>**。

其实这就是一个**组合问题**了。



1. 确定dp数组以及下标的含义

**dp[j] 表示：填满j（包括j）这么大容积的包，<u>有dp[j]种方法</u>**

其实也可以使用二维dp数组来求解本题，dp[i] [j]：使用 下标为[0, i]的nums[i]能够凑满j（包括j）这么大容量的包，有dp[i] [j]种方法。



2. 确定递推公式

有哪些来源可以推出dp[j]呢？ 只要搞到nums[i]，凑成dp[j]就有dp[j - nums[i]] 种方法。

例如：dp[j]，j 为5，

- 已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。
- 已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。
- 已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 容量为5的背包
- 已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 容量为5的背包
- 已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 容量为5的背包

那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。

所以**求组合类问题的公式**，都是类似这种：

```text
dp[j] += dp[j - nums[i]]
```

**这个公式在后面在讲解背包解决排列组合问题的时候还会用到！**



3. dp数组如何初始化

从递推公式可以看出，**在初始化的时候dp[0] 一定要初始化为1，因为<u>dp[0]是在公式中一切递推结果的起源</u>，如果dp[0]是0的话，递推结果将都是0。**

其实不要硬去解释它的含义，就把 dp[0]的情况带入本题看看应该等于多少。

如果数组[0] ，target = 0，那么 bagSize = (target + sum) / 2 = 0。 dp[0]也应该是1， 也就是说给数组里的元素 0 前面无论放加法还是减法，都是 1 种方法。所以本题应该初始化 dp[0] 为 1。

那如果是数组[0,0,0,0,0] target = 0 呢。

其实 此时最终的dp[0] = 32，也就是这五个零子集的所有组合情况，但此dp[0]非彼dp[0]，dp[0]能算出32，其基础是因为dp[0] = 1 累加起来的。

dp[j]其他下标对应的数值也应该初始化为0，从递推公式也可以看出，dp[j]要保证是0的初始值，才能正确的由dp[j - nums[i]]推导出来。



4. 确定遍历顺序

01背包问题一维dp的遍历，**nums放在外循环，target在内循环，且内循环倒序。**



5. 举例推导dp数组

输入：nums: [1, 1, 1, 1, 1], S: 3        bagSize = (S + sum) / 2 = (3 + 5) / 2 = 4

dp数组状态变化如下：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210125120743274.jpg" alt="img" style="zoom:67%;" />

C++代码如下：

```cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int S) {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) sum += nums[i];
        if (abs(S) > sum) return 0; // 此时没有方案
        if ((S + sum) % 2 == 1) return 0; // 此时没有方案
        int bagSize = (S + sum) / 2;
        vector<int> dp(bagSize + 1, 0);
        dp[0] = 1;
        for (int i = 0; i < nums.size(); i++) {
            for (int j = bagSize; j >= nums[i]; j--) {
                dp[j] += dp[j - nums[i]];
            }
        }
        return dp[bagSize];
    }
};
```

- 时间复杂度：O(n × m)，n为正数个数，m为背包容量
- 空间复杂度：O(m)，m为背包容量



### 在求装满背包有几种方法的情况下，递推公式一般为：

```cpp
dp[j] += dp[j - nums[i]];
```









[474.一和零](https://leetcode.cn/problems/ones-and-zeroes/)

给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。

如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。





其实本题并不是多重背包，再来看一下这个图，捋清几种背包的关系

![416.分割等和子集1](https://code-thinking-1253855093.file.myqcloud.com/pics/20210117171307407-20230310132423205.png)

**多重背包是每个物品，数量不同的情况。**

**本题中strs 数组里的元素就是物品，每个物品都是一个！** **而m 和 n相当于是一个背包，两个维度的背包**。

误理解成多重背包主要是把m和n混淆为物品了，感觉这是不同数量的物品，所以以为是多重背包。

但本题其实是01背包问题！只不过这个背包有两个维度，一个是m 一个是n，而不同长度的字符串就是不同大小的待装物品。



动规五部曲：

1. 确定dp数组（dp table）以及下标的含义

**dp[i] [j]：最多有i个0和j个1的strs的最大子集的大小为dp[i] [j]**。

2. 确定递推公式

dp[i] [j] 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1。

dp[i] [j] 就可以是 dp[i - zeroNum] [j - oneNum] + 1。    然后我们在遍历的过程中，取dp[i] [j]的最大值。

所以递推公式：dp[i] [j] = max(dp[i] [j], dp[i - zeroNum] [j - oneNum] + 1);

此时大家可以回想一下01背包的递推公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

对比一下就会发现，**字符串的zeroNum和oneNum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）。** **这就是一个典型的01背包！** 只不过物品的重量有了两个维度而已。

3. dp数组如何初始化

在[动态规划：关于01背包问题，你该了解这些！（滚动数组）中已经讲解了，01背包的dp数组初始化为0就可以。

因为物品价值不会是负数，初始为0，保证递推的时候dp[i] [j]不会被初始值覆盖。

4. 确定遍历顺序

01背包一定是外层for循环遍历物品，内层for循环遍历背包容量且从后向前遍历！

那么本题也是，物品就是strs里的字符串，背包容量就是题目描述中的m和n。

```cpp
for (string str : strs) { // 遍历物品
    int oneNum = 0, zeroNum = 0;
    for (char c : str) {
        if (c == '0') zeroNum++;
        else oneNum++;
    }
    for (int i = m; i >= zeroNum; i--) { // 遍历背包容量且从后向前遍历！
        for (int j = n; j >= oneNum; j--) {
            dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
        }
    }
}
```

有同学可能想，那个遍历背包容量的两层for循环先后循序有没有什么讲究？

<u>没讲究，都是物品重量的一个维度，先遍历哪个都行！</u>



5. 举例推导dp数组

以输入：["10","0001","111001","1","0"]，m = 3，n = 3为例

最后dp数组的状态如下所示：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210120111201512.jpg" alt="474.一和零" style="zoom:67%;" />

以上动规五部曲分析完毕，C++代码如下：

```cpp
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m + 1, vector<int> (n + 1, 0)); // 默认初始化0
        for (string str : strs) { // 遍历物品
            int oneNum = 0, zeroNum = 0;
            for (char c : str) {
                if (c == '0') zeroNum++;
                else oneNum++;
            }
            for (int i = m; i >= zeroNum; i--) { // 遍历背包容量且从后向前遍历！
                for (int j = n; j >= oneNum; j--) {
                    dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
                }
            }
        }
        return dp[m][n];
    }
};
```

- 时间复杂度: O(kmn)，k 为strs的长度

- 空间复杂度: O(mn)

  

## 总结

0-1背包的多种应用，

- [纯 0 - 1 背包](https://programmercarl.com/背包理论基础01背包-2.html)是求 给定背包容量 装满背包 的最大价值是多少。
- [416. 分割等和子集 是求 给定背包容量，能不能装满这个背包。
- [1049. 最后一块石头的重量 II 是求 给定背包容量，尽可能装，最多能装多少
- [494. 目标和是求 给定背包容量，装满背包有多少种方法。
- [474.一和零](https://leetcode.cn/problems/ones-and-zeroes/)是求 给定背包容量，装满背包最多有多少个物品。

所以在代码随想录中所列举的题目，都是 0-1背包不同维度上的应用,细心体会！





● 今日收获，记录一下自己的学习时长

学习时长1.5h	